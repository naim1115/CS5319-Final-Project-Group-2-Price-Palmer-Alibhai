1) Compilation and Implementation Platform:
  
**Client Server Layered Architecture:**

USED:
-Spring Initializr (Back-end):
    -Spring Boot Version 3.3.5, Java JDK 17, Maven, Jar Package Type

-React (Front-end)
   
WHAT TO INSTALL:
-Node.js (For node and npm)
-Java JDK Version 17

HOW TO CONFIGURE:
-Configuration Settings:
    -quiz-platform\src\main\resources\application.properties
  
REQUIRED TO COMPILE:
-Java JDK Version 17 
-Maven Wrapper file used for ease of compilation:
    -'mvnw.cmd'
-Node.js

**Event Driven Architecture:**
  
USED:
-

REQUIRED TO COMPILE:
-
  
2) Compilation

**Client Server Layered Architecture:**

TO COMPILE:
 
**Frontend:**
Ensure that you are in the proper directory:
'cd quiz-platform-frontend'

-‘npm install’
**Installs necessary dependencies to run the frontend**

**Back-end:**
Ensure that you are in the proper directory:
'cd quiz-platform'

THEN:

Apple:
'./mvnw compile'

Windows:
'.\mvnw.cmd compile'
  
**Event Driven Architecture:**

TO COMPILE:
-

3) Execution

**Client Server Layered Architecture:**

TO EXECUTE:

**Front-end:**
'npm start'
   
**Back-end:**
Windows
-'.\mvnw.cmd spring-boot:run'

Apple
'./mvnw spring-boot:run'
  
**Event Driven Architecture:**

TO EXECUTE:
-

4) Differences Between Architectural Designs

**Client Server Layered Architecture:**
-Users interact as 'clients' with the 'server'
-Through RESTful APIs, users can create requests to the server and recieve a response
-Server acts as a data container that provides the responses of information that users request
-Communication is synchonrous, and done through means of HTTP protocol, either using methods of GET, POST, or more


**Event Driven Architecture:**

   Chosen Architecture: Ultimately, we would decide to choose ___

5) Reason For Design Changes

After receiving our project proposal feedback, it was made clear that we should rethink the complexity of our project. In terms of scope, the amount of functionality we would want to implement would be too much, so we decided to scale down our project. While we would not have any major design changes in terms of our prescriptive architecture allowing for a faithful descriptive architecture or ‘as implemented’ project, we just added necessary features. In terms of features added, the most important functionality a quiz platform should have is an ability to login as either a ‘STUDENT’ or ‘TEACHER’ role. And once logged in, depending on the role you would have a set of predefined functionality, or way of interacting with the front-end. If you were logged in as a ‘STUDENT’ you should be able to view quizzes, and take one that interests you. And once taken, you should be able to receive brief feedback on how well you did. On the other hand, when logged in as a ‘TEACHER’, you should be able to create quizzes, and view results from students who are eager to take them. While this is a different approach from many other mainstream quiz platforms like Quizlet, and Kahoot, it encapsulates all functionality necessary to be used as a tool to test teachers to test students' knowledge, and receive basic feedback on what they need to change in their teaching style.  

6) Information Insightful To Grader For Design Rationale

**Client Server Layered:**

In terms of the Client Server Layered architecture the main reasons for choosing this type of architecture would be separation of concerns, modularity, and scalability. By having several distinct layers in the application, each having their own responsibilities it simplifies the process of user interaction from the front-end to the back-end.In terms of separation of concerns, we have multiple layers in the program: 

-Model Layer: Defines the structure of User, Quiz, and Question objects
-Repository: Contains data access to the quizzes.json and users.json files in order to read or write depending on how you interact with the front-end.
-Service Layer: Contains the main business logic of the application, imperative for the Controller layer and Repository layer to intercommunicate
-Controller Layer: Is responsible for handling HTTP requests from the front-end, facilitating communication to the back-end

By having these distinct layers, making our program scalable and modular is a given, as we can do explicit testing at the layer level without running into issues that hinder other components of the program. Two other reasons this is beneficial is it allows for an easier process of finding issues when debugging since you can quickly find the problem, as well as code reusability throughout the project. 

**Event Driven Architecture**